# -*- coding: utf-8 -*-
"""Planys.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vetVGcgjsVTSZLbrUdV8JdMXCTzwf2L8
"""

#import numpy as np
from numpy import sin,cos,tan,arctan2,pi,arctan,Inf
# Inf=99999999
import shapely.geometry as gp
from math import sqrt
import matplotlib.pyplot as plt
from shapely.geometry import point
from shapely.geometry.point import Point

from ortools.constraint_solver import pywrapcp
from ortools.constraint_solver import routing_enums_pb2
from ortools.graph.pywrapgraph import DijkstraShortestPath


def longestside(points):
  edgelengths = [sqrt((points[idx + 1][0] - points[idx][0])**2 + (points[idx + 1][1] - points[idx][1])**2) for idx in range(len(points) - 1)]
  #print(edgelengths)
  lastedge=sqrt((points[-1][0]-points[0][0])**2+(points[-1][1] - points[0][1])**2)
  edgelengths.append(lastedge)
  #print(edgelengths)
  
  if(max(edgelengths)>lastedge):
    maxpos = edgelengths.index(max(edgelengths))
    return points[maxpos],points[maxpos+1]
  else:
    return points[-1],points[0]
#longestside(PL)
# longestside(PointList)

# Operation: Shift origin and rotate axes to align with longest side

#Shift the origin
def originShift(points,newOrigin):
  newPoints=[(points[idx][0]-newOrigin[0],points[idx][1]-newOrigin[1]) for idx in range(len(points))]
  return newPoints
#originShift(PL,(100,101))

#Rotate the axis about origin along edge passing through rotation point
def AxisRotate(points,RotPoint):
  theta=arctan2(RotPoint[1],RotPoint[0])
  newPoints=[(points[idx][0]*cos(theta)+points[idx][1]*sin(theta),-points[idx][0]*sin(theta)+points[idx][1]*cos(theta)) for idx in range(len(points))]
  return newPoints,theta
#print(AxisRotate(PL,PL[1]))

def operatePolygon(points):
  #Extract longest side
  Longside=longestside(points)
  P1=Longside[0]
  P2=Longside[1]
  idxP1=points.index(P1)
  idxP2=points.index(P2)

  
  #Shift origin to P1
  pointsO1=originShift(points,P1)
  #Rotate axes to make P1-P2 as x-axis
  pointsO2,theta=AxisRotate(pointsO1,pointsO1[idxP2])


  return pointsO2,idxP1,idxP2,theta
# print(operatePolygon(PL))

#Decompose cell of operated polygon i.e pointsO2
def CellDecomposition(points):

  #xmin
  P_xmin=min(points)
  print(P_xmin)
  P_xmin=gp.Point(P_xmin)

  #xmax
  P_xmax=max(points)
  print(P_xmax)
  P_xmax=gp.Point(P_xmax)

  P_ymin=min(points,key = lambda i: i[1])
  print(P_ymin)
  P_ymin=gp.Point(P_ymin)

  P_ymax=max(points,key = lambda i: i[1])
  print(P_ymax)
  P_ymax=gp.Point(P_ymax)

  line_max = gp.LineString([gp.Point(P_xmax.x,P_ymax.y),gp.Point(P_xmax.x,P_ymin.y)])
  line_min = gp.LineString([gp.Point(P_xmin.x,P_ymax.y),gp.Point(P_xmin.x,P_ymin.y)])
  poly_points=gp.Polygon(points)
  # sweep0=[gp.LineString(gp.Point(i[0],P_ymax.y),gp.Point(i[0],P_ymin.y)) for i in points]
  sweep0=[]
  for i in points:
    sweep0.append(((i[0],P_ymax.y),(i[0],P_ymin.y)))
    plt.plot([i[0],i[0]], [P_ymax.y,P_ymin.y])
  # print(sweep0)
  Sweep=gp.MultiLineString(sweep0)
  # print(Sweep)
  intersection_list=[]
  for i in Sweep:
    abc=i.intersection(poly_points)  # abscissa
    x=0
    lines=[]
    points=[]
    if type(abc)==gp.collection.GeometryCollection:
      lines.append((abc[0].boundary[0].y, abc[0].boundary[1].y))
      points.append(abc[1].y)
      x=abc[0].boundary[0].x
    elif type(abc)==gp.multilinestring.MultiLineString:
      lines.append((abc[0].boundary[0].y, abc[0].boundary[1].y))
      lines.append((abc[1].boundary[0].y, abc[1].boundary[1].y))
      x=abc[0].boundary[0].x
    elif type(abc)==gp.linestring.LineString:
      lines.append((abc.boundary[0].y, abc.boundary[1].y))
      x=abc.boundary[0].x
    elif type(abc)==gp.point.Point:
      points.append(abc.y)
      x=abc.x
    lst=[x,points,lines]
    intersection_list.append(lst)
    # print(abc)
    # print(lst)
    # print()
  intersection_list = sorted(intersection_list, key=lambda x: x[0])
  print()
  for i in intersection_list:
    print(i)
  print()

  final_poly=[]
  first=[(intersection_list[0][0], intersection_list[0][1][0]), (intersection_list[1][0], intersection_list[1][2][0][0]), (intersection_list[1][0], intersection_list[1][2][0][1]), (intersection_list[0][0], intersection_list[0][1][0])]
  final_poly.append(first)
  for i in range(1, len(intersection_list)-2):
    x1,p1,l1=intersection_list[i]
    x2,p2,l2=intersection_list[i+1]
    if (len(l2)>len(l1) and len(l2)==2 and  l2[0][1]==l2[1][0]):
      l2=[(l2[0][0],l2[1][1])]
    elif (len(l1)>len(l2) and len(l1)==2 and l1[0][1]==l1[1][0]):
      l1=[(l1[0][0],l1[1][1])]
    elif (len(l1)==2 and len(l2)==2 and l2[0][1]==l2[1][0] and l1[0][1]==l1[1][0]):
      l1=[(l1[0][0],l1[1][1])]
      l2=[(l2[0][0],l2[1][1])]
    # print(l1,l2)
    mid1=[]
    if(p1!=[]):
      mid1.append((p1[0],0))
    if(l1!=[]):
      for i in l1:
        mp=(i[0]+i[1])/2
        mid1.append((mp,1))

    mid2=[]
    if(p2!=[]):
      mid2.append((p2[0],0))
    if(l2!=[]):
      for i in l2:
        mp=(i[0]+i[1])/2
        mid2.append((mp,1))
    print(mid1,mid2)

    for i in mid1:
      for j in mid2:
        points=[]
        midpoint_joint = gp.LineString([gp.Point(x1,i[0]),gp.Point(x2,j[0])])
        # flag = midpoint_joint.intersects(poly_points)
        inter=midpoint_joint.intersection(poly_points)
        # print(inter)
        
        print(type(inter)==gp.linestring.LineString)
        
        if type(inter)==gp.linestring.LineString:

          if i[1]==0 and j[1]==1:
            points.append((x1,i[0]))
            for y1,y2 in l2:
              if(j[0]==(y1+y2)/2):
                points.append((x2,y1))
                points.append((x2,y2))
            points.append((x1,i[0]))

          elif i[1]==1 and j[1]==0:
            print("hi")
            points.append((x2,j[0]))
            for y1,y2 in l1:
              if(i[0]==(y1+y2)/2):
                points.append((x1,y1))
                points.append((x1,y2))
            points.append((x2,j[0]))
            
          elif i[1]==1 and j[1]==1:
            first=()
            for y1,y2 in l1:
              if(i[0]==(y1+y2)/2):
                first=(x1,y1)
                points.append((x1,y1))
                points.append((x1,y2))
            for y1,y2 in l2:
              if(j[0]==(y1+y2)/2):
                points.append((x2,y2))
                points.append((x2,y1))
            points.append(first)


        if len(points)>0:
          final_poly.append(points)

        
  n=len(intersection_list)
  last=[(intersection_list[n-1][0], intersection_list[n-1][1][0]), (intersection_list[n-2][0], intersection_list[n-2][2][0][0]), (intersection_list[n-2][0], intersection_list[n-2][2][0][1]), (intersection_list[n-1][0], intersection_list[n-1][1][0])]
  final_poly.append(last)

  return final_poly
  
def smooth(kml_str):
  array=kml_str.split(" ")
  ox=[]
  oy=[]
  for i in range(len(array)):
      lst=array[i].split(",")
      x=(float(lst[0])-80.29821599780011)*100000
      y=(float(lst[1])-13.13286087620951)*100000
      ox.append(x)
      oy.append(y)
  try_x=[]
  try_y=[]

  try_x.append(ox[0])
  try_y.append(oy[0])

  for i in range(len(array)-2):
      temp1 = arctan((oy[i+1]-oy[i])/(ox[i+1]-ox[i])) *180/pi
      temp2 = arctan((oy[i+2]-oy[i+1])/(ox[i+2]-ox[i+1])) *180/pi
      temp = temp2 - temp1
      if abs(temp)>25:
          try_x.append(ox[i+1])
          try_y.append(oy[i+1])

  try_x.append(ox[i+1])
  try_y.append(oy[i+1])

  try_x.append(ox[i+2])
  try_y.append(oy[i+2])

  points=[]
  for i in range(len(try_x)):
      points.append([try_x[i],try_y[i]])
  return points

def print_solution(manager, routing, solution):
    lst=[0]
    print('Objective: {} miles'.format(solution.ObjectiveValue()))
    index = routing.Start(0)
    
    plan_output = 'Best route found for vehicle 0:\n'
    route_distance = 0
    
    while not routing.IsEnd(index):
        plan_output += ' {} ->'.format(manager.IndexToNode(index))
        previous_index = index
        index = solution.Value(routing.NextVar(index))
        route_distance += routing.GetArcCostForVehicle(previous_index, index, 0)
        lst.append(manager.IndexToNode(index))
    plan_output += ' {}\n'.format(manager.IndexToNode(index))
    # lst.append(manager.IndexToNode(index))
    
    print(plan_output)
    plan_output += 'Total distance for route: {}miles\n'.format(route_distance)
    return lst

# Gives the distance between two nodes
def distance_callback(from_index, to_index):
    
    # Convert routing variable Index to distance matrix NodeIndex.
    from_node = manager.IndexToNode(from_index)
    to_node = manager.IndexToNode(to_index)
    return data['distance_matrix'][from_node][to_node]

def midpoint(cell):
  cx1,cy1=0,0
  n1=len(cell)
  for x,y in cell:
    cx1+=x
    cy1+=y
  cx1=cx1/n1
  cy1=cy1/n1
  return (cx1,cy1)

def distance(poly,cell1,cell2,Inf):
  # print(cell1)
  cell1=cell1.copy()
  cell2=cell2.copy()
  cell1.pop(-1)
  cell2.pop(-1)
  dist=0

  cx1,cy1=0,0
  n1=len(cell1)
  for x,y in cell1:
    cx1+=x
    cy1+=y
  cx1=cx1/n1
  cy1=cy1/n1

  cx2,cy2=0,0
  n2=len(cell2)
  for x,y in cell2:
    cx2+=x
    cy2+=y
  cx2=cx2/n2
  cy2=cy2/n2

  poly_points=gp.Polygon(poly)
  midpoint_joint = gp.LineString([gp.Point(cx1,cy1),gp.Point(cx2,cy2)])
  inter=midpoint_joint.intersection(poly_points)
  # print(cx1,cy1,cx2,cy2)
  # print(inter,n1,n2)
  flag = type(inter)==gp.linestring.LineString
  # flag=True
  if (flag==False):
    # print(flag)
    # dist=Inf
    dist=Inf
  else:
    dist=sqrt((cx2-cx1)**2 + (cy2-cy1)**2)

  return dist

def func(i,j):
  # global Inf
  # Inf = 999999999
  return distance_matrix2[i][j]

def path(n,p1,p2):
  short_path=DijkstraShortestPath(node_count=n, start_node=p1, end_node=p2, graph=func, disconnected_distance=bignum*100)
  return short_path





#Test points for verification
AnchorPoints=[[1,1],[2,3],[5,0],[4,-2],[0,-2]]
# AnchorPoints=[[0,0], [0,2], [1,1], [0,0]]
PL=[tuple(l) for l in AnchorPoints]
#print(PL)
#Actual map points
# RealPoints=[[80.2982159978001,13.1328608762095],[80.2979672070574,13.1318277303457],[80.2991076628975,13.1316966051867],[80.2994403802413,13.1316529923465],[80.2993776262009,13.1310911123474],[80.2979372632814,13.1312845746907],[80.297610569375,13.130067292519],[80.2980625290242,13.1299946593292],[80.2983508642784,13.1302445671714],[80.2994121318522,13.1299843413577],[80.3002351868059,13.1296542055612],[80.3004458653306,13.1290641311287],[80.3005020135633,13.1286632848746],[80.3003610901532,13.1280418004981],[80.3002566222694,13.1277693728526],[80.3000525602131,13.1275280741189],[80.2996895159738,13.1273267810673],[80.2985010174895,13.1275377053046],[80.298190610155,13.1269846390685],[80.2982624612807,13.1266384783667],[80.298630608753,13.1261649802337],[80.298661735718,13.1256859802337],[80.29872099323,13.1251472775363],[80.2986666520998,13.1245795774647],[80.2979944868499,13.1244329791752],[80.2974557768208,13.1246465082633],[80.2977784379775,13.1240636209093],[80.2990179632531,13.1245261643156],[80.2994215614677,13.1241817368871],[80.2989053938218,13.1237513033455],[80.2984376311746,13.1234940167266],[80.2996644501652,13.1231362836669],[80.3002058346454,13.1234471700024],[80.3002394271785,13.123468020095],[80.3006605058793,13.1237551341122],[80.3009143379241,13.1242705364067],[80.3012265245774,13.124830534544],[80.3016264531936,13.1254518073308],[80.3020167260107,13.1261799620163],[80.3026172206797,13.1269618081526],[80.302895544735,13.1276024467152],[80.3033043162478,13.1280799391069],[80.3033382285584,13.1281388740622],[80.3037115028477,13.1288337910283],[80.3040252941719,13.1291461163457],[80.3038802377704,13.1292764583487],[80.3033471262172,13.1299655949978],[80.3030137865166,13.1297521805143],[80.3010754826003,13.1328722295249],[80.3006907745798,13.1332004489859],[80.2995692553596,13.1334836836321],[80.2994531642517,13.1331876878335],[80.3003726172484,13.1328722253555],[80.3006062080364,13.1324411843554],[80.3001956106281,13.1323564180065],[80.2996930182829,13.1323564207542],[80.2991348405313,13.1325020215653],[80.2984388730736,13.1327726356158],[80.2982159978001,13.1328608762095]]
# smooth1=[[0.0, 0.0], [-24.87907426456104, -103.31458637686808], [122.43824412792037, -120.78838629889788], [116.16284007942568, -176.97638620592926], [-27.873451863058563, -157.63015187797436], [-60.542842508937156, -279.3583690499091], [-15.346877586353003, -286.6216880258676], [13.486647834781706, -261.6309038080189], [201.9189005835642, -320.6670648289389], [228.6015763246496, -419.75913348686333], [147.35181737535186, -553.4095142149198], [28.501968942862277, -532.3170904828701], [-2.538764502446611, -587.6237140919116], [4.646348064341055, -622.2397842750026], [41.461095293016115, -669.5895975738608], [50.49954299209958, -771.3598673118938], [45.06542997546603, -828.1298744808652], [-22.151095012645783, -842.7897034298582], [-76.02209792452186, -821.4367946209222], [-43.75598225720978, -879.7255300200036], [80.19654530215803, -833.471189382884], [120.55636675825099, -867.9139322380181], [22.163337449399023, -936.6859482890177], [144.84523651674408, -972.4592542520227], [244.45080792645513, -910.5742097229808], [580.9296371808159, -371.47598637385926], [513.1128417133368, -289.5281211628742], [479.77887165728816, -310.86956951700273], [247.47767797066444, 33.957277646123885], [135.32575594865648, 62.28074225909097], [123.7166451588223, 32.68116240011665], [215.66194483284562, 1.134914599987269], [239.02102363564381, -41.9691854078863], [22.28752735220496, -8.82405936692976], [0.0, 0.0]]
# smooth2=[[74.58839752700896, 171.78377316806603], [358.1053641809717, 107.24461824302978], [551.3685411585811, -267.60443806299605], [617.9332341062604, -290.6153837589187], [1729.115586341834, 2639.69213473505], [1447.6817476733572, 2764.407822806092], [1396.8596848812354, 2652.759018886108], [1145.589549628312, 2694.9025483460787], [899.6141428283977, 2165.027868691105], [1009.3485865439789, 2126.5321336160882], [955.4720132484817, 1977.2017982191414], [825.910663398588, 2002.7926760350922], [696.0970521305399, 1669.6479510921235], [835.6889798804445, 1616.8151651790197], [783.8487023676066, 1498.2065496520036], [641.1926625716546, 1538.942897253115], [468.11521637977194, 1224.2467888480492], [603.9769784919713, 1160.8679878230887], [564.0307126171251, 1044.4628977630543], [432.6646261588962, 1041.5962631530106], [242.16385606763424, 798.4310563040608], [428.63845652334476, 744.5637314960507], [400.1875428187418, 660.7770913340971], [238.85461200734426, 720.0569380561461], [238.85461200734426, 720.0569380561461], [74.58839752700896, 171.78377316806603]]
# PointList=[tuple(l) for l in smooth2]

kml1="80.29821599780011,13.13286087620951,0 80.29796720705747,13.13182773034574,0 80.2991076628975,13.13169660518675,0 80.29944038024139,13.13165299234652,0 80.29937762620091,13.13109111234745,0 80.29793726328148,13.13128457469073,0 80.29761056937502,13.13006729251901,0 80.29806252902425,13.12999465932925,0 80.29835086427846,13.13024456717143,0 80.29941213185222,13.12998434135773,0 80.30023518680595,13.12965420556122,0 80.30044586533064,13.12906413112875,0 80.30050201356336,13.12866328487464,0 80.30036109015327,13.12804180049814,0 80.30025662226946,13.12776937285265,0 80.3000525602131,13.12752807411891,0 80.29968951597387,13.12732678106736,0 80.29850101748954,13.12753770530468,0 80.29819061015509,13.12698463906859,0 80.29826246128076,13.12663847836676,0 80.29863060875304,13.12616498023377,0 80.29866173571808,13.12568598023374,0 80.29872099323003,13.12514727753639,0 80.29866665209987,13.1245795774647,0 80.29799448684999,13.12443297917521,0 80.29745577682087,13.1246465082633,0 80.29777843797754,13.12406362090931,0 80.29901796325314,13.12452616431568,0 80.2994215614677,13.12418173688713,0 80.29890539382183,13.1237513033455,0 80.29843763117461,13.12349401672662,0 80.29966445016528,13.12313628366699,0 80.30020583464541,13.12344717000246,0 80.30023942717858,13.12346802009502,0 80.30066050587938,13.12375513411228,0 80.30091433792411,13.12427053640675,0 80.30122652457746,13.12483053454407,0 80.30162645319366,13.12545180733082,0 80.30201672601071,13.12617996201633,0 80.30261722067974,13.12696180815264,0 80.30289554473505,13.12760244671527,0 80.30330431624785,13.12807993910696,0 80.30333822855845,13.12813887406227,0 80.30371150284772,13.12883379102835,0 80.30402529417192,13.12914611634577,0 80.30388023777046,13.12927645834875,0 80.30334712621725,13.12996559499788,0 80.30301378651669,13.12975218051434,0 80.30107548260035,13.13287222952495,0 80.30069077457982,13.13320044898597,0 80.2995692553596,13.1334836836321,0 80.2994531642517,13.13318768783351,0 80.30037261724844,13.13287222535551,0 80.30060620803647,13.13244118435543,0 80.30019561062818,13.1323564180065,0 80.29969301828299,13.13235642075422,0 80.29913484053139,13.13250202156531,0 80.29843887307364,13.13277263561584,0 80.29821599780011,13.13286087620951,0"
kml2="80.29896188177538,13.13457871394119,0 80.30179705144192,13.13393332239194,0 80.30251262471795,13.13258722535745,0 80.3037296832117,13.13018483182888,0 80.30439533014118,13.12995472237192,0 80.30455207341703,13.13097186008446,0 80.30469291859053,13.13205528046478,0 80.3074130726969,13.13881532179428,0 80.30969697138669,13.14515284587348,0 80.31109872275637,13.14839401014196,0 80.31550715366353,13.15925779755686,0 80.31269281527685,13.16050495443757,0 80.31218459464893,13.15938846639837,0 80.3096718932964,13.15980990169297,0 80.30836266443212,13.15689452707756,0 80.3072121392284,13.15451115489642,0 80.30830948366555,13.15412619754567,0 80.30801269745258,13.15313937038605,0 80.3077707179326,13.1526328941917,0 80.3064751044341,13.15288880296986,0 80.30517696832142,13.14955735572043,0 80.30657288759892,13.1490290278613,0 80.30605448482379,13.14784294170603,0 80.30462792442583,13.14825030518204,0 80.30289714996391,13.14510334409799,0 80.30425576758503,13.14446955608774,0 80.30385630492628,13.14330550518714,0 80.3025426440617,13.14327683884104,0 80.30063763636079,13.14084518677255,0 80.30074407799306,13.14083845736187,0 80.30250238236535,13.14030651352447,0 80.3022178732283,13.13946864712285,0 80.30060454392019,13.14006144559007,0 80.29896188177538,13.13457871394119,0"
smoothened=smooth(kml1)
PointList=[tuple(l) for l in smoothened]


#AUV specs
AUV_length=0.2
AUV_breadth=0.1
AUV_Loc=[0,0.3]

poly_test = gp.Polygon(PL)
poly= gp.Polygon(PointList)

a,b,c,d=operatePolygon(PointList)

ox=[]
oy=[]
for i in a:
    ox.append(i[0])
    oy.append(i[1])

plt.plot(ox,oy)

final_poly=CellDecomposition(a)
plt.show()

for i in final_poly:
  print(i)
# final_poly.pop(36)
for i in final_poly:
  ox=[]
  oy=[]
  for x,y in i:
    ox.append(x)
    oy.append(y)
  plt.plot(ox,oy)
  # plt.pause(0.1)

plt.show()

n=len(final_poly)
# distance_matrix=[[0]*n]*n
distance_matrix=[]
for i in range(n+1):
  lst=[]
  for j in range(n+1):
    if i==n and j==n:
      dis=0
    elif i==n:
      if j==n-1:
        dis=-10
      else:
        dis=Inf*10
    elif j==n:
      if i==n-1:
        dis=-1
      else:
        dis=Inf*10
    else:
      dis=distance(a, final_poly[i], final_poly[j],Inf)
    lst.append(dis)
    # print(dis)
  distance_matrix.append(lst)

print()
for i in distance_matrix:
  print(i)

print()
# print(distance_matrix[46][45])

data={}
data['distance_matrix'] = distance_matrix
data['no_of_vehicles'] = 1
data['depot'] = 0

manager = pywrapcp.RoutingIndexManager(
    len(data['distance_matrix']), 
    data['no_of_vehicles'],
    data['depot'])

routing = pywrapcp.RoutingModel(manager)

transit_callback_index = routing.RegisterTransitCallback(distance_callback)

routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

search_parameters = pywrapcp.DefaultRoutingSearchParameters()
search_parameters.first_solution_strategy = (
    routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)

# Call the SolveWithParameters() and print the solution
solution = routing.SolveWithParameters(search_parameters)
# print()
# print(solution)
lst=[]
if solution:
    lst=print_solution(manager, routing, solution)
    # print(lst)

points1=lst[1:]
print(points1)
points2=[]

distance_matrix2=[]
bignum=9999999999
for i in range(n+1):
  lst=[]
  for j in range(n+1):
    if i==n and j==n:
      dis=0
    elif i==n:
      if j==n-1:
        dis=0
      else:
        dis=bignum
    elif j==n:
      if i==n-1:
        dis=0
      else:
        dis=bignum
    else:
      dis=distance(a, final_poly[i], final_poly[j],bignum)
    lst.append(dis)
    # print(dis)
  distance_matrix2.append(lst)

# Inf = 999999999

n=len(distance_matrix2)
path_lstx=[]
path_lsty=[]
# print(path(n,points1[0],points1[1]))
for i in range(len(points1)-1):
  a=points1[i]
  b=points1[i+1]
  # print(a,b)
  ans=path(n, a, b)
  actual_path=ans[1][::-1]
  for i in range(1,len(actual_path)):
    x,y=midpoint(final_poly[actual_path[i]-1])
    path_lstx.append(x)
    path_lsty.append(y)
  print(a,b,ans)



for i in points1:
  if(i<n-1):
    ox,oy=[],[]
    for x,y in final_poly[i]:
      ox.append(x)
      oy.append(y)
      plt.plot(ox,oy)
    plt.pause(0.1)
plt.show()

# ox,oy=[],[]
# for i in range(len(path_lstx)-2):
#   ox.append(path_lstx[i])
#   oy.append(path_lsty[i])
#   plt.plot(ox,oy,"b")
#   plt.pause(1)
# plt.show()
  

print()
print()
# print(distance(a, final_poly[0], final_poly[1]))

# ox,oy=[],[]
# for x,y in final_poly[36]:
#   ox.append(x)
#   oy.append(y)
# plt.plot(ox,oy)
# plt.show()
